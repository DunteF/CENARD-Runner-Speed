<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Runner Speed Radar (Web, iOS-friendly)</title>
  <!-- Simple styles for clarity -->
  <style>
    :root{--bg:#0b0c10;--card:#16181d;--text:#e6edf3;--muted:#8b949e;--accent:#2ea043;--warn:#d29922;--danger:#f85149}
    body{margin:0;background:var(--bg);color:var(--text);font:16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"}
    header{padding:12px 16px;background:#0f1116;border-bottom:1px solid #262b33;position:sticky;top:0;z-index:10}
    h1{font-size:18px;margin:0}
    main{display:grid;grid-template-columns:1.2fr 1fr;gap:16px;padding:16px}
    @media (max-width: 900px){main{grid-template-columns:1fr;}}
    .card{background:var(--card);border:1px solid #262b33;border-radius:14px;overflow:hidden}
    .card header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;background:rgba(255,255,255,0.02);border-bottom:1px solid #262b33}
    .card header h2{font-size:14px;margin:0;color:#c9d1d9}
    .card .content{padding:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button, select, input[type="number"], input[type="text"], input[type="range"]{
      background:#0f1116;color:var(--text);border:1px solid #262b33;border-radius:10px;padding:8px 10px
    }
    button{cursor:pointer}
    button.primary{background:var(--accent);border-color:var(--accent);color:#081b0d}
    button.warn{background:var(--warn);border-color:var(--warn);color:#1b1404}
    button.ghost{background:transparent}
    .pill{display:inline-flex;gap:6px;align-items:center;border:1px solid #2a2f37;padding:4px 8px;border-radius:999px;color:var(--muted)}
    .grid{display:grid;gap:10px}
    label small{color:var(--muted)}
    .stat{display:flex;flex-direction:column;gap:4px;padding:8px 10px;background:#0f1116;border-radius:10px;border:1px solid #262b33}
    .stat b{font-size:20px}
    canvas{max-width:100%;width:100%;background:#000}
    video{display:none}
    .hint{color:var(--muted);font-size:13px}
    .badge{display:inline-block;padding:4px 8px;border-radius:999px;border:1px solid #2a2f37;color:#9da7b3}
    .ok{color:#0dbb7c;border-color:#0dbb7c33;background:#0dbb7c11}
    .warn2{color:#d29922;border-color:#d2992233;background:#d2992211}
    .err{color:#f85149;border-color:#f8514933;background:#f8514911}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
  </style>
</head>
<body>
  <header>
    <h1>üèÉ‚Äç‚ôÇÔ∏è Runner Speed Radar ‚Äî m/s from a side view (client‚Äëside)</h1>
  </header>

  <main>
    <!-- LEFT: Video & overlay -->
    <section class="card" id="videoCard">
      <header>
        <h2>Camera & Overlay</h2>
        <span id="geomBadge" class="badge warn2">calibration: not set</span>
      </header>
      <div class="content">
        <div class="row" style="justify-content:space-between">
          <div class="row">
            <button id="btnStart" class="primary">Start Camera</button>
            <button id="btnStop" class="ghost">Stop</button>
            <button id="btnFlip" class="ghost">Flip Cam</button>
          </div>
          <div class="row">
            <button id="btnCalib2" class="warn">Tap 2 markers (scale)</button>
            <button id="btnResetCalib" class="ghost">Reset</button>
          </div>
        </div>
        <p class="hint">Tip: place two ground markers exactly <b>10.00 m</b> apart along the lane and tap both.
          The app will use them for gate timing and continuous speed scale.</p>
        <video id="video" playsinline muted></video>
        <canvas id="overlay" width="1280" height="720"></canvas>
        <p class="hint mono" id="status">status: idle</p>
      </div>
    </section>

    <!-- RIGHT: Controls & readout -->
    <section class="card">
      <header><h2>Controls & Readout</h2></header>
      <div class="content grid">
        <div class="grid" style="grid-template-columns:1fr 1fr 1fr">
          <div class="stat"><span>Instantaneous</span><b id="vInst">‚Äî m/s</b><small id="vInstKmh" class="hint">‚Äî km/h</small></div>
          <div class="stat"><span>1 s avg</span><b id="vAvg">‚Äî m/s</b><small id="vAvgKmh" class="hint">‚Äî km/h</small></div>
          <div class="stat"><span>Gate (A‚ÜíB)</span><b id="vGate">‚Äî m/s</b><small id="vGateKmh" class="hint">‚Äî km/h</small></div>
        </div>

        <div class="row">
          <label>Marker distance (m)
            <input type="number" id="markerMeters" value="10" min="1" step="0.5" style="width:90px">
          </label>
          <label>Smoothing (s)
            <input type="range" id="smoothSec" min="0" max="1" step="0.05" value="0.35">
          </label>
          <label>FOV (¬∞) <small>approx.</small>
            <input type="number" id="fovDeg" value="65" min="30" max="120" step="1" style="width:90px">
          </label>
        </div>

        <div class="row">
          <span class="pill">Tracker: <span id="trackerLabel">Pose (mid‚Äëhip)</span></span>
          <span class="pill">FPS: <span id="fps">‚Äî</span></span>
          <span class="pill">Video: <span id="vidInfo">‚Äî</span></span>
        </div>

        <details>
          <summary>Advanced (homography & projection)</summary>
          <div class="hint">
            We assume the runner moves along the line defined by the two tapped ground markers. The app projects the tracked point onto that line, converts pixels‚Üímeters using your distance, and differentiates over time. For best accuracy, keep the camera fixed and side‚Äëon.
          </div>
        </details>
      </div>
    </section>
  </main>

  <!-- MediaPipe Pose Landmarker (Tasks Vision) -->
  <script type="module">
    const statusEl = document.getElementById('status');
    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');

    const btnStart = document.getElementById('btnStart');
    const btnStop = document.getElementById('btnStop');
    const btnFlip = document.getElementById('btnFlip');
    const btnCalib2 = document.getElementById('btnCalib2');
    const btnResetCalib = document.getElementById('btnResetCalib');

    const markerMetersInput = document.getElementById('markerMeters');
    const smoothSecInput = document.getElementById('smoothSec');
    const fovDegInput = document.getElementById('fovDeg');

    const vInstEl = document.getElementById('vInst');
    const vAvgEl = document.getElementById('vAvg');
    const vGateEl = document.getElementById('vGate');
    const vInstKmhEl = document.getElementById('vInstKmh');
    const vAvgKmhEl = document.getElementById('vAvgKmh');
    const vGateKmhEl = document.getElementById('vGateKmh');
    const fpsEl = document.getElementById('fps');
    const vidInfoEl = document.getElementById('vidInfo');
    const geomBadge = document.getElementById('geomBadge');

    // State
    let stream = null;
    let facingMode = 'environment';
    let running = false;
    let requestId = null;

    // Calibration via two taps (A & B) along lane
    let tapMode = false;
    let markerA = null; // {x,y}
    let markerB = null; // {x,y}

    // Derived calibration
    let metersBetween = Number(markerMetersInput.value);
    let pxBetween = null; // pixel distance between A & B
    let metersPerPx = null; // scale along AB

    // Tracking & speed
    let lastT = 0;
    let lastS = null; // projected distance along AB in meters
    const samples = []; // {t, s, vInst}

    // Gate timing
    let crossedA = false;
    let tA = null, tB = null;

    // FPS calc
    let lastFpsT = performance.now();
    let frameCount = 0;

    // Utils
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const dist = (p, q) => Math.hypot(p.x - q.x, p.y - q.y);

    function drawScene(landmark){
      ctx.save();
      ctx.clearRect(0,0,canvas.width, canvas.height);
      // Video frame
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      // Calibration visuals
      if(markerA){ drawMarker(markerA, 'A'); }
      if(markerB){ drawMarker(markerB, 'B'); }
      if(markerA && markerB){
        // AB line
        ctx.strokeStyle = 'rgba(46,160,67,0.9)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(markerA.x, markerA.y);
        ctx.lineTo(markerB.x, markerB.y);
        ctx.stroke();
      }

      // Tracked point
      if(landmark){
        ctx.fillStyle = '#58a6ff';
        ctx.beginPath();
        ctx.arc(landmark.x, landmark.y, 6, 0, Math.PI*2);
        ctx.fill();
      }

      ctx.restore();
    }

    function drawMarker(p, label){
      ctx.save();
      ctx.fillStyle = '#2ea043';
      ctx.strokeStyle = '#2ea043';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 7, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(p.x, p.y, 12, 0, Math.PI*2);
      ctx.stroke();
      ctx.fillStyle = '#c9d1d9';
      ctx.font = '12px system-ui';
      ctx.fillText(label, p.x + 10, p.y - 10);
      ctx.restore();
    }

    function projectPointOnLine(p, a, b){
      // Return scalar projection length from A toward B (in pixels)
      const abx = b.x - a.x, aby = b.y - a.y;
      const apx = p.x - a.x, apy = p.y - a.y;
      const ab2 = abx*abx + aby*aby;
      if(ab2 === 0) return 0;
      const t = (apx*abx + apy*aby) / ab2; // scalar along AB
      return t * Math.sqrt(ab2); // in pixels
    }

    function updateScale(){
      metersBetween = Number(markerMetersInput.value);
      if(markerA && markerB){
        pxBetween = dist(markerA, markerB);
        metersPerPx = metersBetween / pxBetween;
        geomBadge.textContent = `calibration: ${metersBetween.toFixed(2)} m over ${pxBetween.toFixed(1)} px`;
        geomBadge.className = 'badge ok';
      } else {
        metersPerPx = null;
        geomBadge.textContent = 'calibration: not set';
        geomBadge.className = 'badge warn2';
      }
    }

    markerMetersInput.addEventListener('change', updateScale);

    btnCalib2.addEventListener('click', ()=>{
      tapMode = true; markerA = null; markerB = null; updateScale();
      statusEl.textContent = 'status: Tap two ground markers along lane (A then B).';
    });

    btnResetCalib.addEventListener('click', ()=>{
      markerA = null; markerB = null; updateScale();
      crossedA = false; tA = tB = null; vGateEl.textContent = '‚Äî m/s'; vGateKmhEl.textContent = '‚Äî km/h';
    });

    canvas.addEventListener('click', (e)=>{
      if(!tapMode) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      if(!markerA){ markerA = {x,y}; statusEl.textContent = 'status: Tap marker B.'; }
      else if(!markerB){ markerB = {x,y}; tapMode = false; statusEl.textContent = 'status: Calibration set.'; updateScale(); }
    });

    // Camera
    async function startCamera(){
      if(stream) await stopCamera();
      try{
        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode, width: {ideal:1280}, height:{ideal:720} }, audio:false });
      }catch(err){
        statusEl.textContent = 'camera error: ' + err.message;
        return;
      }
      video.srcObject = stream;
      await video.play();

      // Resize canvas to video
      const settings = stream.getVideoTracks()[0].getSettings();
      const w = settings.width || video.videoWidth || 1280;
      const h = settings.height || video.videoHeight || 720;
      canvas.width = w; canvas.height = h;
      vidInfoEl.textContent = `${w}√ó${h}`;

      running = true;
      pump();
    }

    async function stopCamera(){
      running = false;
      if(requestId){ cancelAnimationFrame(requestId); requestId = null; }
      if(stream){
        stream.getTracks().forEach(t=>t.stop());
        stream = null;
      }
    }

    btnStart.addEventListener('click', startCamera);
    btnStop.addEventListener('click', stopCamera);
    btnFlip.addEventListener('click', ()=>{ facingMode = (facingMode==='environment'?'user':'environment'); startCamera(); });

    // Pose tracker (mid‚Äëhip)
    import {PoseLandmarker, FilesetResolver} from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3';
    let landmarker = null;
    let runningMode = 'VIDEO';

    async function initPose(){
      const filesetResolver = await FilesetResolver.forVisionTasks(
        // Uses the CDN-hosted WASM assets; no extra hosting needed
        'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm'
      );
      landmarker = await PoseLandmarker.createFromOptions(filesetResolver, {
        baseOptions: {
          // Lite model is faster on mobile. You can switch to full/heavy by name.
          modelAssetPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm/pose_landmarker_lite.task'
        },
        runningMode,
        numPoses: 1
      });
      statusEl.textContent = 'status: Pose model ready.';
    }
    initPose();

    function hipFromLandmarks(list){
      if(!list || !list.length) return null;
      const lm = list[0].landmarks;
      if(!lm || lm.length < 33) return null;
      const L = lm[23]; // left_hip
      const R = lm[24]; // right_hip
      if(!L || !R) return null;
      // Convert normalized coords ‚Üí pixel space
      const x = ((L.x + R.x)/2) * canvas.width;
      const y = ((L.y + R.y)/2) * canvas.height;
      return {x, y};
    }

    function movingAverage(seconds){
      const now = performance.now();
      const windowMs = Number(smoothSecInput.value) * 1000;
      if(windowMs <= 0) return null;
      let sum = 0, count = 0;
      for(let i=samples.length-1; i>=0; i--){
        if(now - samples[i].t > windowMs) break;
        if(Number.isFinite(samples[i].vInst)){
          sum += samples[i].vInst; count++;
        }
      }
      return count ? (sum / count) : null;
    }

    function updateGate(t, s){
      if(markerA && markerB && Number.isFinite(s)){
        // s is meters from A along AB (can be <0 or >metersBetween)
        if(!crossedA && s >= 0){ crossedA = true; tA = t; }
        if(crossedA && tA!=null && s >= metersBetween && tB==null){ tB = t; const dt = (tB - tA)/1000; if(dt>0){ const v = metersBetween/dt; setGate(v); } }
        // Reset if runner goes back before A by >2 m
        if(crossedA && s < -2){ crossedA = false; tA = tB = null; }
      }
    }

    function setInst(v){
      if(v == null || !Number.isFinite(v)){
        vInstEl.textContent = '‚Äî m/s';
        vInstKmhEl.textContent = '‚Äî km/h';
      } else {
        vInstEl.textContent = v.toFixed(2) + ' m/s';
        vInstKmhEl.textContent = (v*3.6).toFixed(2) + ' km/h';
      }
    }

    function setAvg(v){
      if(v == null || !Number.isFinite(v)){
        vAvgEl.textContent = '‚Äî m/s';
        vAvgKmhEl.textContent = '‚Äî km/h';
      } else {
        vAvgEl.textContent = v.toFixed(2) + ' m/s';
        vAvgKmhEl.textContent = (v*3.6).toFixed(2) + ' km/h';
      }
    }

    function setGate(v){
      if(v == null || !Number.isFinite(v)){
        vGateEl.textContent = '‚Äî m/s';
        vGateKmhEl.textContent = '‚Äî km/h';
      } else {
        vGateEl.textContent = v.toFixed(2) + ' m/s';
        vGateKmhEl.textContent = (v*3.6).toFixed(2) + ' km/h';
      }
    }

    async function pump(){
      if(!running) return;
      requestId = requestAnimationFrame(pump);

      const t = performance.now();
      const w = canvas.width, h = canvas.height;

      // Predict/detect pose
      let landmarkPx = null;
      if(landmarker && video.readyState >= 2){
        const res = await landmarker.detectForVideo(video, t);
        const hip = hipFromLandmarks(res.landmarks);
        if(hip) landmarkPx = hip;
      }

      drawScene(landmarkPx);

      // FPS
      frameCount++;
      if(t - lastFpsT > 1000){ fpsEl.textContent = frameCount.toString(); frameCount = 0; lastFpsT = t; }

      // Geometry & speed
      if(landmarkPx && markerA && markerB && metersPerPx){
        // scalar pixel distance from A projected onto AB (can be negative) ‚Üí meters
        const pxAlong = projectPointOnLine(landmarkPx, markerA, markerB);
        const sMeters = (pxAlong - 0) * metersPerPx; // A is 0 m

        let vInst = null;
        if(lastS != null && lastT > 0){
          const dt = (t - lastT)/1000;
          if(dt > 0){
            const ds = sMeters - lastS;
            // Clamp absurd spikes (jitter)
            if(Math.abs(ds) < 20) vInst = clamp(ds/dt, -20, 20);
          }
        }

        samples.push({t, s: sMeters, vInst});
        while(samples.length > 600) samples.shift(); // ~10s @60fps

        setInst(vInst);
        const mav = movingAverage(Number(smoothSecInput.value));
        setAvg(mav);
        updateGate(t, sMeters);

        lastS = sMeters; lastT = t;
      } else {
        setInst(null); setAvg(null);
      }

      statusEl.textContent = `status: ${landmarker? 'tracking‚Ä¶' : 'loading model‚Ä¶'} ${metersPerPx? '| scale OK' : '| scale N/A'}`;
    }

    // UI listeners
    smoothSecInput.addEventListener('input', ()=>{/* live update */});

    // iOS hints
    if(!('mediaDevices' in navigator)){
      statusEl.textContent = 'Your browser does not support camera access (getUserMedia). Use Safari/Chrome on iOS 16+.';
    }
  </script>
</body>
</html>
